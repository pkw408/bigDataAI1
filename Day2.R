## 7.16
# 단일값(scalar) : 단 하나의 값을 저장합니다(Day1 내용)

# 백터(vector) : 두 개 이상의 값을 가지고 있는 변수. Salar와 다른점은 값이 나열되어있다는 점이고, 한 가지의 자료형만 가질 수있다.
vec.a <- c(1,2,3,4,5)
vec.a
class(vec.a)

vec.b <- c(1:5) #연속되는 값을 넣을 경우, ':'을 사용해서 시작값:종료값으로 1씩 증가하는 연속된 값을 저장할 수 있다.
vec.b

vec.c <- c('대한민국','프랑스', '미국', '영국')
vec.c
class(vec.c)

vec.d <- c(T,F,T,F)
vec.d
class(vec.d)

# 다른 형태의 자료형을 저장할 때
# 자료형이 다를 경우 자료형의 우선순위에 따라 자료가 변형됩니다.
vec.e <- c(100,T,10)
vec.e
class(vec.e)

vec.f <- c(100, T, "박경원")     # 자료형의 우선순위: 문자형 < Numeric < logical
vec.f

# seq() : 변수에 여러개의 값을 저장할 수 있다.
# seq(시작값, 종료값, [by=증가값])  [] : option / 증가값을 생략하면 1로 기본값이 설정
vec.g <- seq(1,10) # Integer
vec.g <- c(1:10) # Integer
vec.g <- c(1,2,3,4,5,6,7,8,9,10) # Numeric > Integer
vec.g
class(vec.g)

vec.h <- seq(1,10,by=2)
vec.h

# 백터의 연산
# 여러개의 값을 기억하는 백터에 숫자를 연산하면 모든 데이터 값에 연산된다.
vec.i  <- vec.g + 5 
vec.i 

# 여러개의 값을 기억하는 백터끼리 연산을 하면 같은 위치의 값과 연산이됩니다. 단, 여러개의 값을 기억하는 백터끼리의 연산은 값의 개수가 같아야한다.
vec.g + vec.i 

# 만약 저장된 값의 개수가 다를 경우 값의 개수가 적은쪽의 값이 처음부터 반복되어 연산합니다.
vec.g + vec.a

# 백터의 요소 접근
ver.j <- c(50,90,70,60,45,35,15,100,80,85)
ver.j[1] # vec.j의 첫번째 요소를 선택하는 방법
ver.j[1:5] # 백터의 첫번째 부터 다섯번째 요소 선택하기
ver.j[-8] # 백터의 여덟번째 요소만 빼고 선택하기
ver.j[-1:-3] # 백터의 첫번째 부터 세번째 요소 빼고 선택 
ver.j[3:1] # 세번째 요소부터 첫번째 요소까지 역순으로 선택


# rep(): 특정 요소를 반복하여 선택
# rep(값, 반복횟수)
rep(1, 5)
rep(vec.i,2)
rep(1:3, each=2)

# 집합에 사용되는 함수
# max(): 최대값을 선택
max(ver.j)
# min(); 최소값을 선택
min(ver.j)
# mean(): 평균을 계산
mean(ver.j)
# sum() : 총힙을 계산
sum(ver.j)


# 문제1
# 1부터 10사이의 백터를 만들어 v1이라는 변수에 저장
# 각 원소 값들에 2를 곱한 결과롤 백터 v2로 만듭니다.
# v2에서 최대값을 뽑아 max_v에 저장
# v2에서 최소값을 뽑아 min_v에 저장
# v2에서 평균값을 뽑아 mean_v에 저장
# v2에서 핪을 뽑아 sum_v에 저장
# v2에서 5번째 요소를 제외하고 v3라는 변수에 저장합니다.
# 모든 결과값을 화면에 출력하시오.
v1 <- c(1:10)
v2 <- v1 * 2
max_v <- max(v2)
min_v <- min(v2)
mean_v <- mean(v2)
sum_v <- sum(v2)
v3 <- v2[-5]
v1;v2;max_v;min_v;mean_v;sum_v;v3

# 문제2
# seq() 또느 rep() 함수를 이용하여 아래 결과가 나오도록 출력
# 1,3,5,7,9
seq(1,9,by=2)
# 1,1,1,1,1,1
rep(1,6)
# 1,2,3,1,2,3,1,2,3
rep(1:3,3)
# 1,1,2,2,3,3,4,4
rep(1:4,each=2)


# 연산자
# 산술 연산자
# 덧셈,뺄셈,곱셈,나눗셈, **(거듭제곱), %%(나머지)
10 %% 3

# 할당 연산자
# <-, =, ->

# 비교 연산자 --> 결과값이 논리형이 나온다.
# ==, !=, >, >=, <=, <
5 == 7

# 논리 연산자
# &&(AND), ||(OR), !(NOT)
3 > 1 && 7 == 7
3 > 1 || 4 == 7
!(3 > 1)

# 행렬(Matrix): 2차원 데이터를 저장합니다. **
#     1열 2열 3열
# 1행 1   4    7
# 2행 2   5    8
# 3행 3   6    9

# matrix(): 행렬 데이터를 만들어준다.
# 행과 열을 지정하지 않으면 12행 1열인 matrix가 만들어집니다.
mat.a <- matrix(c(1:12))

mat.b <- matrix(c(1:12),ncol=4) # ncol 옵션으로 4열의 값을 저장하는  matrix가 만들어집니다.
mat.c <- matrix(c(1:12),nrow=4) # ncol 옵션으로 4행의 값을 저장하는  matrix가 만들어집니다.

# matrix는 값이 채워지는 방향이 열방향을 우선으로 채워진다.
# 행 방향을 데이터를 입력할때, byrow=T 옵션을 사용해준다.
mat.d <- matrix(c(1:12),nrow=4, byrow=T) # ncol 옵션으로 4열의 값을 저장하는  matrix가 만들어집니다.

# 행렬의 요소 접근
mat.d[7] # matrix에서 지정된 위치의 값을 한개 선택 --> 열 우선 방식
mat.d[1,] # matrix에서 지정된 행 전체를 선택합니다.
mat.d[,1] # matrix에서 지정된 열 전체를 선택합니다.
mat.d[3,1] # 지정된 위치(3행, 1열)의 값을 한 개 선택함.


mat.d[1:2,] # (지정된 범위내) 1행과 2행 검색 --> 값이 연속될 때
mat.d[c(1,3),] # 지정된 범위의 행 값을 선택 --> 값이 연속되지 않을 때
mat.d[,c(1,3)]

mat.d[-1,] # 1행을 제외한 값을 선택
mat.d[,-2] # 2열을 제외한 값을 선택
mat.d[-c(1:2),]

# Matrix에 관련된 함수
vec1 <- c(1,2,3,4,5)
vec2 <- c(2,4,6,8,10)
vec3 <- c(3,6,9,12,15) # 어떻게 matrix로 만들어 줄 수 있을까??

#cbind() : 열 중심으로 백터값을 행렬로 만들어줌
mat.e <- cbind(vec1,vec2,vec3)

#rbind() : 행 중심으로 백터값을 행렬로 만들어줌
mat.f <- rbind(vec1,vec2,vec3)

#names() : 백터값에 제목(열이름)을 붙여준다.
vec4 <-c(1:3)
names(vec4) <- c("1열", "2열", "3열")
vec4

names(vec4) <- LETTERS[1:3]

# colnames(): 행렬에서 열의 이름을 붙여준다.
colnames(mat.f) <- c("1열", "2열", "3열", "4열", "5열")
mat.f

# rownames(): 행렬에서 행의 이름을 붙여준다.
rownames(mat.f) <- c("1행", "2행", "3행")
mat.f


# 문제3
# 1부터 10까지 출력하는데 3씩 중각되는 형태로(1,4,7,10) 저장되는 백터를 정의하여 v3 변수에 저장.
# (단, 각각 값마다 "A", "B", "C", "D" 라는 이름을 부여한다.)
v3 <- c(seq(1,10, by=3))
names(v3) <- LETTERS[1:4]
v3
    

# 문제4
# 아래와 같이 값이 구성되는 메트릭를 정의하여 m1에 저장합니다. 1,2,3의 백터 n1, 4,5,6의 백터 n2,7,8,9의 백터n3을 이용하여 matrix구성
n1 <- c(1:3)
n2 <- c(4:6) 
n3 <- c(7:9)

m1 <- cbind(n1,n2,n3)
colnames(m1)<-NULL # 열 이름을 없애준다.
m1



















